/*
 * Simple interface to the Xilinx MIG generated DDR2 controller.
 * 
 * The controller is capable of fast streams of accesses, and this
 * module aims to simply do the minimum amount to get the controller
 * working on the wishbone bus.
 * 
 * This means, each read or write will incur a read of (minimum burst
 * x data-width) = 8 words, which will sit in a small bit of distram
 * until something else is read, outside of those 8 words.
 * Of course, reads will be scrapped and new data will be read over,
 * and in the case of writes, it has to be written back to the RAM.
 * 
 * I will try to make this as parametisable as much as possible, allowing
 * greater caching, or perhaps greater associativity, so a few spots of
 * memory can be cached here at once, but at first it will be a simple 
 * interface between wishbone and the Xilinx MIG DDR2 interface, implenting
 * as simple a interface as possible.
*/
module ml501_ddr2_wb_if ( 
    input [31:0]       wb_adr_i,
    input 	       wb_stb_i,
    input 	       wb_cyc_i,
    input 	       wb_we_i,
    input [3:0]        wb_sel_i,
    input [31:0]       wb_dat_i,
    output [31:0]      wb_dat_o,
    output reg 	       wb_ack_o,
			  
    output [12:0]      ddr2_a,
    output [1:0]       ddr2_ba,
    output 	       ddr2_ras_n,
    output 	       ddr2_cas_n,
    output 	       ddr2_we_n,
    output 	       ddr2_cs_n,
    output 	       ddr2_odt,
    output 	       ddr2_cke,
    output [7:0]       ddr2_dm,

    inout [63:0]       ddr2_dq,		  
    inout [7:0]        ddr2_dqs,
    inout [7:0]        ddr2_dqs_n,
    output [1:0]       ddr2_ck,
    output [1:0]       ddr2_ck_n,
			  
    input 		    ddr2_if_clk,
    input 		    clk200,
    input 		    rst,
			  
    input 		    wb_clk,
    input 		    wb_rst);
   
			  
`include "ml501_ddr2_params.v"

      
   parameter cache_lines = 1;
   parameter bits_per_word = 32;
   parameter bytes_per_word = 4;   
   parameter words_per_line = 8; /* (ddr2 burst * ddr2 data width / bits_per_word) */
   parameter bytes_per_line = 32; /* (words_per_line * bytes_per_word) */
   parameter cache_byte_address_width = 5; /* log2(bytes_per_line) */
   parameter cache_word_address_width = 3; /* log2(words_per_line) */


   wire 	      wb_req;   
   reg 		      wb_req_r;

   wire 	      new_wb_req;
   reg 		      new_wb_req_r;

   reg 		      wb_req_addr_hit;

   // Current line's address
   reg [31:cache_byte_address_width] cached_address_line;
   
   reg 				cached_address_valid;
   reg 				cache_dirty;
   
   // Hopefully this turns into a dual-port RAM
   
   // synthesis attribute ram_style of mem is distributed
   reg [31:0] 			mem [0:words_per_line-1];
   
   wire [31:0] 			cache_do_wb, cache_do_mig;   
   
   // registered address for cache RAM
   reg [cache_word_address_width-1:0] cache_addr_wb, cache_addr_mig; 
   wire 			      cache_we_wb, cache_we_mig;

   wire [31:0] 			      cache_di_wb;
   reg [31:0] 			      cache_di_mig; // Is actually comb.
   
   reg [cache_word_address_width - 1: 0] writeback_counter, writeback_counter_r,writeback_counter_r_r;
   reg 					 writeback_doing;
   reg 					 writeback_data_we;

   reg [cache_word_address_width - 1: 0] readfrom_counter, readfrom_counter_r;
   reg 					 readfrom_start;   
   reg 					 readfrom_doing;
   reg 					 readfrom_doing_r;

   // Assemble the 128-bit words here when writing or store them
   // here when reading from SDRAM
   reg [127:0] 				 app_holding_reg0, app_holding_reg1;
   reg 					 app_holding_reg_sel;
   
   // DDR2 MIG interface wires
   wire 				 app_af_afull;
   wire 				 app_wdf_afull;
   wire 				 app_wdf_wren;
   wire 				 app_af_wren;
   wire [30:0] 				 app_af_addr;
   wire [2:0] 				 app_af_cmd;
   wire [(APPDATA_WIDTH)-1:0] 		 app_wdf_data;
   wire [(APPDATA_WIDTH/8)-1:0] 	 app_wdf_mask_data;
   wire 				 rd_data_valid;
   wire [(APPDATA_WIDTH)-1:0] 		 rd_data_fifo_out;
   wire 				 phy_init_done;

   // mux for RMW on wishbone side
   assign cache_di_wb[31:24] = wb_sel_i[3] ? wb_dat_i[31:24] : cache_do_wb[31:24];
   assign cache_di_wb[23:16] = wb_sel_i[2] ? wb_dat_i[23:16] : cache_do_wb[23:16];
   assign cache_di_wb[15: 8] = wb_sel_i[1] ? wb_dat_i[15: 8] : cache_do_wb[15: 8];
   assign cache_di_wb[ 7: 0] = wb_sel_i[0] ? wb_dat_i[ 7: 0] : cache_do_wb[ 7: 0];

   // Cache's Wishbone-side r/w logic
   always @(posedge wb_clk)
     if (wb_req)
       cache_addr_wb <= wb_adr_i[(cache_word_address_width+2)-1:2];
   
   assign cache_do_wb = mem[cache_addr_wb];
   assign wb_dat_o = cache_do_wb;
   
   always @(posedge wb_clk)
     if (wb_req & wb_we_i & wb_req_addr_hit & wb_ack_o)
       mem[cache_addr_wb] <= cache_di_wb;
   
   
   // Wishbone request detection
   assign wb_req = wb_stb_i & wb_cyc_i & phy_init_done; 
   always @(posedge wb_clk)
     wb_req_r <= wb_req;
   
   assign new_wb_req = wb_req & !wb_req_r;
   always @(posedge wb_clk)
     new_wb_req_r <= new_wb_req;
   
   // Register whether it's a hit or not
   // As more lines are added, add them to this check.
   always @(posedge wb_clk)
     if (wb_rst)
       wb_req_addr_hit <= 0;   
     else 
       wb_req_addr_hit <= wb_req & (cached_address_line == 
				    wb_adr_i[31:cache_byte_address_width]) &
			  cached_address_valid;
   
   always @(posedge wb_clk)
     if (wb_rst)
       wb_ack_o <= 0;
     else
       wb_ack_o <= wb_req_addr_hit & !wb_ack_o;

   always @(posedge wb_clk)   
     if (readfrom_counter_r == 1) /* Unsure about this */
       cached_address_line <= wb_adr_i[31:cache_byte_address_width];
   
   
   // Cache dirty signal
   always @(posedge wb_clk)
     if (wb_req & wb_we_i & wb_req_addr_hit & wb_ack_o)
       cache_dirty <= 1;
     else if (readfrom_counter_r == 1)
       cache_dirty <= 0;
   
   always @(posedge wb_clk)
     if (wb_rst)
       cached_address_valid <= 0;
     else if  (readfrom_counter_r == 1) /* Unsure about this */
       cached_address_valid <= 1;
     else if (writeback_counter_r_r == 1)
       cached_address_valid <= 0;
   
   /*
    * Cache writeback to DDR2
    * 
    * Load the words out of the cache into DDR2 MIG write data fifo.
    * On the last, also write in the address.
    * 
    */
   
`define WRITEBACK_CONDITION (new_wb_req_r && !wb_req_addr_hit && cached_address_valid && cache_dirty)
   // If burst length is 4 and SDRAM DQ is 64-bits, and the ddr2 MIG fifo is 
   // 128-wide and we're loading from a 128-bit wide ram, then we need to do
   // (64 * 4) / 32 = 8 reads from our RAM, and we need to do a write to the 
   // fifo every (128 / 32) = 4th word we pull out.
   
`define WRITEBACK_COUNTER_LOAD (7)
   // Pulse app_wdf when writeback_counter_r == 4 or 0, but testing 0 is bad
   // so we'll test the registered, registered version for 5 and 1 ([1:0] == 1)
`define WRITEBACK_FIFO_WE (writeback_counter_r_r[1:0] == 2'b01)

   // app_holding_reg0 load control
   always @(posedge wb_clk)
     if (writeback_counter_r[1:0] == 2'b11)
       app_holding_reg0[31:0] <= cache_do_mig;
     else if (writeback_counter_r[1:0] == 2'b10)
       app_holding_reg0[63:32] <= cache_do_mig;
     else if (writeback_counter_r[1:0] == 2'b01)
       app_holding_reg0[95:64] <= cache_do_mig;
     else if ((writeback_counter_r[1:0] == 2'b00) & `WRITEBACK_CONDITION)
       app_holding_reg0[127:96] <= cache_do_mig;
     else if ((app_holding_reg_sel == 0) && rd_data_valid)
       app_holding_reg0 <= rd_data_fifo_out;
   
   // app_holding_reg0 load control
   always @(posedge wb_clk)
     if ((app_holding_reg_sel == 1) && rd_data_valid)
       app_holding_reg1 <= rd_data_fifo_out;
   
   always @(posedge wb_clk)
     writeback_data_we <= (writeback_counter_r_r[1:0] == 2'b01);
   
   
   // Load for writeback sequence when we've got a miss, valid address 
   // and dirty cache.
   always @(posedge wb_clk)
     if (wb_rst)
       writeback_counter <= 0;
     else if (|writeback_counter)
       writeback_counter <= writeback_counter - 1;
     else if `WRITEBACK_CONDITION
       writeback_counter <= `WRITEBACK_COUNTER_LOAD;   
   
   always @(posedge wb_clk)
     writeback_counter_r <= writeback_counter;
   
   always @(posedge wb_clk)
     writeback_counter_r_r <= writeback_counter_r;
   
   always @(posedge wb_clk)
     writeback_doing <= ((|writeback_counter)|(|writeback_counter_r)|(|writeback_counter_r_r));
   
   /*
    * Cache read from DDR2
    * 
    * Read will simply put the address onto the bus and await for
    * the fifo to start spitting things out.
    * 
    */
`define READFROM_CONDITION (new_wb_req_r && !wb_req_addr_hit && !cached_address_valid && !(|writeback_counter_r))
   
   always @(posedge wb_clk)
     if (wb_rst)
       readfrom_doing <= 0;
     else if (wb_ack_o)
       readfrom_doing <= 0;   
     else if (`READFROM_CONDITION)
       readfrom_doing <= 1;
   
   //assign readfrom_doing = `READFROM_CONDITION;
   
   always @(posedge wb_clk)
     readfrom_doing_r <= readfrom_doing;
   
   always @(posedge wb_clk)
     readfrom_start <= (!readfrom_doing_r & readfrom_doing);

   
   reg 					 readfrom_start_r;
   always @(posedge wb_clk)
     readfrom_start_r <= readfrom_start;
					 
   reg 					 readfrom_counter_go, readfrom_counter_go_r;

   // Reg to indicate the counter should increment.
   // Also used as WE to the MIG side of the RAM
   always @(posedge wb_clk)
     if (wb_rst)
       readfrom_counter_go <= 0;
     else
       begin
	  if (app_holding_reg_sel & rd_data_valid)
	    readfrom_counter_go <= 1;
	  else if (&readfrom_counter)
	    readfrom_counter_go <= 0;
       end
   
   always @(posedge wb_clk)
     readfrom_counter_go_r <= readfrom_counter_go;
   
   // Readfrom counter
   // We use this counter to copy in the data from the holding registers
   
   always @(posedge wb_clk)
     if (readfrom_counter_go)
       readfrom_counter <= readfrom_counter + 1;
     else
       readfrom_counter <= 0;
   
   always @(posedge wb_clk)
     readfrom_counter_r <= readfrom_counter;
   
   always @(posedge wb_clk)
     if (wb_rst)
       app_holding_reg_sel <= 0;
     else if (rd_data_valid)
       app_holding_reg_sel <= ~app_holding_reg_sel;


   always @(/*AUTOSENSE*/app_holding_reg0 or app_holding_reg1
	    or readfrom_counter)
     case (readfrom_counter)
       3'b000 : cache_di_mig <= app_holding_reg0[31:0];
       3'b001 : cache_di_mig <= app_holding_reg0[63:32];
       3'b010 : cache_di_mig <= app_holding_reg0[95:64];
       3'b011 : cache_di_mig <= app_holding_reg0[127:96];
       3'b100 : cache_di_mig <= app_holding_reg1[31:0];
       3'b101 : cache_di_mig <= app_holding_reg1[63:32];
       3'b110 : cache_di_mig <= app_holding_reg1[95:64];
       3'b111 : cache_di_mig <= app_holding_reg1[127:96];
       default: cache_di_mig <= 0;	  
     endcase // case (readfrom_counter)
   
   //assign cache_di_mig = rd_data_fifo_out;
   assign cache_we_mig = readfrom_counter_go;   
   
   // Address for MIG side of cache
   // Expect it to always go back to 0!
   always @(posedge wb_clk)
     if (wb_rst)
       cache_addr_mig <= 0;
     else if (readfrom_start)
       cache_addr_mig <= 0;
     else if ((|writeback_counter) | readfrom_counter_go)
       cache_addr_mig <= cache_addr_mig + 1;
   
   always @(posedge wb_clk)
     if (cache_we_mig)
       mem[cache_addr_mig] <= cache_di_mig;
   
   assign cache_do_mig = mem[cache_addr_mig];
   
   // Whenever writeback counter is counting down, generate
   // the write-enable to the data fifo
   assign app_wdf_wren = (writeback_data_we);
   
   assign app_wdf_data = cache_do_mig;
   
   assign app_af_addr = (writeback_doing) ? 
			{4'd0,cached_address_line} : 
			{4'd0, wb_adr_i[31:cache_byte_address_width]} ;
   
   assign app_af_wren = ((writeback_data_we & !writeback_counter_r_r[2]) |
			 (readfrom_start) &
			 !app_af_afull );
			 /*readfrom_doing ) &*/
   

   
   assign app_wdf_mask_data = 0;
   
   // CMD, 1 = read, 0 = write
   assign app_af_cmd[0] = |readfrom_doing;
   assign app_af_cmd[2:1] = 0;


   ml501_ddr2_wb_if_cache cache_mem0
     (/*AUTOINST*/
      // Outputs
      .wb_do				(wb_do[31:0]),
      .ddr2_do				(ddr2_do[127:0]),
      // Inputs
      .wb_clk				(wb_clk),
      .wb_addr				(wb_addr[2:0]),
      .wb_di				(wb_di[31:0]),
      .wb_we				(wb_we),
      .wb_sel				(wb_sel[3:0]),
      .wb_en				(),
      .ddr2_clk				(ddr2_clk),
      .ddr2_addr			(ddr2_addr),
      .ddr2_di				(ddr2_di[127:0]),
      .ddr2_we				(ddr2_we));
   
   
   
   
   ddr2_mig #
     (
     .BANK_WIDTH            (BANK_WIDTH),
     .CKE_WIDTH             (CKE_WIDTH),
     .CLK_WIDTH             (CLK_WIDTH),
     .COL_WIDTH             (COL_WIDTH),
     .CS_NUM                (CS_NUM),
     .CS_WIDTH              (CS_WIDTH),
     .CS_BITS               (CS_BITS),
     .DM_WIDTH                     (DM_WIDTH),
     .DQ_WIDTH              (DQ_WIDTH),
     .DQ_PER_DQS            (DQ_PER_DQS),
     .DQ_BITS               (DQ_BITS),
     .DQS_WIDTH             (DQS_WIDTH),
     .DQS_BITS              (DQS_BITS),
     .HIGH_PERFORMANCE_MODE (HIGH_PERFORMANCE_MODE),
     .ODT_WIDTH             (ODT_WIDTH),
     .ROW_WIDTH             (ROW_WIDTH),
     .APPDATA_WIDTH         (APPDATA_WIDTH),
     .ADDITIVE_LAT          (ADDITIVE_LAT),
     .BURST_LEN             (BURST_LEN),
     .BURST_TYPE            (BURST_TYPE),
     .CAS_LAT               (CAS_LAT),
     .ECC_ENABLE            (ECC_ENABLE),
     .MULTI_BANK_EN         (MULTI_BANK_EN),
     .ODT_TYPE              (ODT_TYPE),
     .REDUCE_DRV            (REDUCE_DRV),
     .REG_ENABLE            (REG_ENABLE),
     .TREFI_NS              (TREFI_NS),
     .TRAS                  (TRAS),
     .TRCD                  (TRCD),
     .TRFC                  (TRFC),
     .TRP                   (TRP),
     .TRTP                  (TRTP),
     .TWR                   (TWR),
     .TWTR                  (TWTR),
     .SIM_ONLY              (SIM_ONLY),
     .RST_ACT_LOW           (RST_ACT_LOW),
     .CLK_TYPE                     (CLK_TYPE),
     .DLL_FREQ_MODE                (DLL_FREQ_MODE),
     .CLK_PERIOD            (CLK_PERIOD)
       )
   ddr2_mig0
     (
     .sys_clk           (ddr2_if_clk),
     .idly_clk_200      (clk200),
     .sys_rst_n         (sys_rst_out),
     .ddr2_ras_n        (ddr2_ras_n),
     .ddr2_cas_n        (ddr2_cas_n),
     .ddr2_we_n         (ddr2_we_n),
     .ddr2_cs_n         (ddr2_cs_n),
     .ddr2_cke          (ddr2_cke),
     .ddr2_odt          (ddr2_odt),
     .ddr2_dm           (ddr2_dm),
     .ddr2_dq           (ddr2_dq),
     .ddr2_dqs          (ddr2_dqs),
     .ddr2_dqs_n        (ddr2_dqs_n),
     .ddr2_ck           (ddr2_ck),
     .ddr2_ck_n         (ddr2_ck_n),
     .ddr2_ba           (ddr2_ba),
     .ddr2_a            (ddr2_a),
     
      //.clk0_tb           (wb_clk),
      //.rst0_tb           (wb_rst),
      .usr_clk (wb_clk),
     .app_af_afull      (app_af_afull),
     .app_wdf_afull     (app_wdf_afull),
     .rd_data_valid     (rd_data_valid),
     .rd_data_fifo_out  (rd_data_fifo_out),
     .app_af_wren       (app_af_wren),
     .app_af_cmd        (app_af_cmd),
     .app_af_addr       (app_af_addr),
     .app_wdf_wren      (app_wdf_wren),
     .app_wdf_data      (app_wdf_data),
     .app_wdf_mask_data (app_wdf_mask_data),
     .phy_init_done     (phy_init_done)
      );
     

endmodule // ml501_ddr2_wb_if
// Local Variables:
// verilog-library-directories:("." "ddr2_mig")
// verilog-library-extensions:(".v" ".h")
// End:

 	      
   
   

module ml501_ddr2_wb_if_cache(
			      wb_clk,
			      wb_addr,
			      wb_di,
			      wb_do,
			      wb_we,
			      wb_sel,
			      wb_en,

			      ddr2_clk,
			      ddr2_addr,
			      ddr2_di,
			      ddr2_do,
			      ddr2_we
			      );
   input wb_clk;
   input [2:0] wb_addr;
   input [31:0] wb_di;
   output [31:0] wb_do;
   input 	 wb_we;
   input [3:0] 	 wb_sel;
   input 	 wb_en;
   
   input 	ddr2_clk;
   input 	ddr2_addr;
   input [127:0] ddr2_di;
   output [127:0] ddr2_do;
   input 	  ddr2_we;
   
   wire [3:0] 	  wb_sel_we;
   assign wb_sel_we = {4{wb_we}} & wb_sel;
   
   
   genvar 	  i;
   generate
      for (i = 0; i < 4; i = i + 1)
	// RAMB36: 32k+4k Parity Paramatizable True Dual-Port BlockRAM
	//         Virtex-5
	// Xilinx HDL Libraries Guide, version 10.1.2
	RAMB36 #(
		 .SIM_MODE("SAFE"), // Simulation: "SAFE" vs. "FAST", see "Synthesis and Simulation Design Guide" for details
		 .DOA_REG(0), // Optional output registers on A port (0 or 1)
		 .DOB_REG(0), // Optional output registers on B port (0 or 1)
		 .INIT_A(36’h000000000), // Initial values on A output port
		 .INIT_B(36’h000000000), // Initial values on B output port
		 .RAM_EXTENSION_A("NONE"), // "UPPER", "LOWER" or "NONE" when cascaded
		 .RAM_EXTENSION_B("NONE"), // "UPPER", "LOWER" or "NONE" when cascaded
		 .READ_WIDTH_A(9), // Valid values are 1, 2, 4, 9, 18, or 36
		 .READ_WIDTH_B(36), // Valid values are 1, 2, 4, 9, 18, or 36
		 .SIM_COLLISION_CHECK("NONE"), // Collision check enable "ALL", "WARNING_ONLY",
		 //   "GENERATE_X_ONLY" or "NONE"
		 .SRVAL_A(36’h000000000), // Set/Reset value for A port output
		 .SRVAL_B(36’h000000000), // Set/Reset value for B port output
		 .WRITE_MODE_A("WRITE_FIRST"), // "WRITE_FIRST", "READ_FIRST", or "NO_CHANGE"
		 .WRITE_MODE_B("WRITE_FIRST"), // "WRITE_FIRST", "READ_FIRST", or "NO_CHANGE"
		 .WRITE_WIDTH_A(9), // Valid values are 1, 2, 4, 9, 18, or 36
		 .WRITE_WIDTH_B(36), // Valid values are 1, 2, 4, 9, 18, or 36
		 ) RAMB36_inst 
     (
      //.CASCADEOUTLATA(CASCADEOUTLATA), // 1-bit cascade A latch output
      //.CASCADEOUTLATB(CASCADEOUTLATB), // 1-bit cascade B latch output
      //.CASCADEOUTREGA(CASCADEOUTREGA), // 1-bit cascade A register output
      //.CASCADEOUTREGB(CASCADEOUTREGB), // 1-bit cascade B register output
      .DOA(wb_do[(i+1)*8-1:(i*8)]),      // 8-bit A port data output
      .DOB(ddr2_do[(i+1)*32-1:i*32]),      // 32-bit B port data output
      //      .DOPA(DOPA),    // A port parity data output
      //      .DOPB(DOPB),    // B port parity data output
      .ADDRA(wb_addr), // A port address input
      .ADDRB(ddr2_addr), // B port address input
      .CASCADEINLATA(0), // 1-bit cascade A latch input
      .CASCADEINLATB(0), // 1-bit cascade B latch input
      .CASCADEINREGA(0), // 1-bit cascade A register input
      .CASCADEINREGB(0), // 1-bit cascade B register input
      .CLKA(wb_clk),     // 1-bit A port clock input
      .CLKB(ddr2_clk),     // 1-bit B port clock input
      .DIA(wb_di[(i+1)*8-1:(i*8)]),       // 8-bit A port data input
      .DIB(ddr2_di[(i+1)*32-1:i*32]),       // 32-bit B port data input
      .DIPA(0),     // 4-bit A port parity data input
      .DIPB(0),     // 4-bit B port parity data input
      .ENA(wb_en),       // 1-bit A port enable input
      .ENB(1),       // 1-bit B port enable input
      .REGCEA(0), // 1-bit A port register enable input
      .REGCEB(0), // 1-bit B port register enable input
      .SSRA(0),     // 1-bit A port set/reset input
      .SSRB(0),     // 1-bit B port set/reset input
      .WEA(wb_sel_we[i]),       // 4-bit A port write enable input
      .WEB(ddr2_we)        // 4-bit B port write enable input
      );
      
   endgenerate
endmodule // ml501_ddr2_wb_if_cache

  